#!/usr/bin/env python

#from xml.etree import ElementTree as ET
import argparse
import sys
import os
import configurations
import runtime_jmx


class cli(object):
    def __init__(self):
        # want "ias configure name" to run the configuration setup for "name"
        # want "ias run <with all the other params>" to actually run the thing
        # https://chase-seibert.github.io/blog/2014/03/21/python-multilevel-argparse.html
        parser = argparse.ArgumentParser(usage='ias <command> [<args>]')

        parser.add_argument('command', help='Subcommand to run')
        args = parser.parse_args(sys.argv[1:2])
        if not hasattr(self, args.command):
            print(f'Unrecognized command: {args.command}')
            parser.print_help()
            exit(1)

        getattr(self, args.command)()  # runs command of the same name

    def configure(self):
        parser = argparse.ArgumentParser(description='For setting up user/jdbc impala connectivity.')
        parser.add_argument('config_section')
        args = parser.parse_args(sys.argv[2:])

        if args.config_section == 'ls':
            # list impala config sections
            # a little sloppy here, you could want to name your config profile "ls"
            configurations.list_configurations()

        else:
            configurations.add_configuration(args.config_section)

    def run(self):
        parser = argparse.ArgumentParser(description='For executing the JMeter load against Impala')
        parser.add_argument('-i', '--impala_config', help=f"the name of an Impala config profile from {configurations.config_filename} to be used (required)")
        parser.add_argument('-s', '--sql', help="SQL statement to be used, overrides SQL provided using -F or --sqlFile")
        parser.add_argument('-F', '--sqlFile', help="file containing SQL to be used, unless -s or --sql is present")

        args = parser.parse_args(sys.argv[2:])
        sql = ''

        if not args.impala_config:
            print('Must specify a Impala config profile')
            parser.print_help()
            exit(1)

        if not args.sql and not args.sqlFile:
            print('Must supply SQL statement via --sql or --sqlFile')
            parser.print_help()
            exit(1)

        if args.sql:
            print(f'Using argument-supplied SQL statement')
            sql = args.sql
        elif args.sqlFile:
             print(f'Using SQL from {args.sqlFile}')
             with open(args.sqlFile, 'r') as f:
                 sql = f.read()

        # build the runtime myconfig.jmx
        document_root = runtime_jmx.read_xml()

        # get specific config values from .impala_autoscale.conf
        impala_config = configurations.get_configuration(args.impala_config)

        # replace placeholder values with actual values & write out myconfig.jmx
        runtime_jmx.replace_username(root=document_root, username=impala_config['username'])
        runtime_jmx.replace_password(root=document_root, password=impala_config['password'])
        runtime_jmx.replace_dbUrl(root=document_root, dbUrl=impala_config['jdbc_url'])
        runtime_jmx.replace_sql(root=document_root, sql=sql)
        runtime_jmx.write_config(root=document_root)

        os.system('impala-autoscale.sh')
        #os.system('HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" CLASSPATH=$(pwd) ./apache-jmeter-5.4.3/bin/jmeter -n -t myconfig.jmx -l ./resultsfile -e -o output')


#
#
# def read_xml():
#     tree = ET.parse('config.jmx')
#     root = tree.getroot()
#     return root
#
#
# def replace_username(root, username):
#     root.find('.//stringProp[@name="username"]').text = username
#
#
# def replace_password(root, password):
#     root.find('.//stringProp[@name="password"]').text = password
#
#
# def replace_dbUrl(root, dbUrl):
#     root.find('.//stringProp[@name="dbUrl"]').text = dbUrl
#
#
# def replace_sql(root, sql):
#     root.find('.//stringProp[@name="query"]').text = sql
#
#
# def write_config(root):
#     with open('myconfig.jmx', 'wb') as f:
#         tree = ET.ElementTree(document_root)
#         tree.write(f)



# parser = argparse.ArgumentParser()
# parser.add_argument('configure', help='For setting up user/jdbc impala connectivity.')
# parser.add_argument('-c', '--config', default='default', help=f"the name of the config section from {configurations.config_filename} to be used")
# parser.add_argument('-s', '--sql', help="SQL statement to be used, overrides SQL provided using -F or --sqlFile")
# parser.add_argument('-F', '--sqlFile', help="file containing SQL to be used, unless -s or --sql is present")
#
# args = parser.parse_args()
#
# if args.configure and args.config:
#     configurations.add_configuration()
#
# else:
#     if args.config:
#         config_section = args.config
#         print(f'Using config section {config_section}')
#
#     if args.sql:
#         sql = args.sql
#         if args.sqlFile:
#             print(f'Overriding {args.sqlFile} with aurgment-supplied SQL statment')
#         else:
#             print('Using argument-supplied SQL')
#
#     if args.sqlFile and not args.sql:
#         print(f'reading SQL from {args.sqlFile}')
#         with open(args.sqlFile, 'r') as f:
#             sql = f.read()
#
#     if not args.sqlFile and not args.sql:
#         print('A query must be supplied using --sql OR --sqlFile')
#         # TODO:  validate if > encoding to &gt; is going to work ok
#         raise Exception('No SQL supplied either via command line argument or SQL file.')


cli()

# read boilerplate XML config for JMeter
#document_root = read_xml()

# get specific config values from impala_autoscale.conf
#config = configurations.get_configuration(config_section)

# replace placeholder values with actual values & write out myconfig.jmx
#replace_username(root=document_root, username=config['username'])
#replace_password(root=document_root, password=config['password'])
#replace_dbUrl(root=document_root, dbUrl=config['jdbc_url'])
#replace_sql(root=document_root, sql=sql)
#write_config(root=document_root)

